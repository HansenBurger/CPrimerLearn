# 3 process data

OOP的本质是设计并扩展自己的数据类型。

## 3.1 简单变量

存储的流程：

1. 开辟内存空间(内存大小-足够存储变量的类型)
2. 将该内存空间标记为变量名
3. 将值存入内存空间

读取的流程：

1. 通过变量名访问内存空间
2. 读取内存空间的值

### 3.1.1 变量名

命名规则：

1. 名称中字符、数字和下划线
2. 第一个字符不能是数字
3. 区分大小写字母
4. 不能使用C++关键字用作名称
5. 保留使用(**双下划线，下划线开头**)
6. 长度无限制(看IDE)

### 3.1.2 整型(类型)

计算机表现得整数是整数得子集(本身无限大)

类型：char，short，int，long，long long (各自有有无符号类型)

不同类型的长度根据操作系统和IDE选择，基本规则:

1. short ≥ 16 bit
2. int至少和short一样长
3. long至少32位，且至少与int一样长
4. long long至少64位，且至少与long一样长

sizeof **不是函数，是运算符**，对于变量可以不用括号，对于类型名要括号

支持的特异的赋值方法(不推荐使用)

```c++
int n(3);
int emus{7};
int rheas = {12};
```

> 如果不对函数内部定义的变量进行初始化，该变量的值将是不确定的。这意味着该变量的值将是它被创建之前，相应内存单元保存的值。

### 3.1.3 无符号类型

用**unsigned**声明，同时会增大最大值的范围(负值变到正值)

整数溢出方向：
![exceed](https://www.welivesecurity.com/wp-content/uploads/2022/02/Figure-6.png)

### 3.1.4 类型选择

int 自然长度，计算机处理效率最高。

根据应用的需求来定义变量类型，节省内存资源(char最省)。

### 3.1.5 整型字面值

常量计数方式:

1. 10进制：1-9
2. 8进制：0第一位，1-7第二位
3. 16进制：0x

在默认情况下cout以十进制显示，需要用hex、oct等来切换显示方式。

### 3.1.6 确定常量的类型

```c++
cout << "Year: " << 1492 << endl;
```

没有声明的变量为**常量**，可以增加后缀来定义类型(大小写和顺序不影响)

如:

1. 1492ul(无符号long)
2. 1492l(long)

对于常量，默认使用int存储，如果长度溢出则会自动开辟内存空间(int -> long -> long long)

### 3.1.7 char类型: 字符和小整数

字符在内存中存的是字符的编码，即整数，整数和字符之间有对应关系(最常见的ASCII字符集)

![ASCII](https://imgconvert.csdnimg.cn/aHR0cDovL2MuYmlhbmNoZW5nLm5ldC91cGxvYWRzL2FsbGltZy8xOTA0MjYvNC0xWjQyNjE0MTIxMTYzOC5naWY)

显示字符: 提取内存中的整数找到对应字符
存储字符: 找到字符对应的整数存入内存

> cin和cout的行为都是由变量类型引导的，M对应的整数77，如果是int类型则直接显示77

下面代码中ch和ch_i在内存中存储值一致，但是cout输出由变量类型决定。

```c++
char ch = 'M';
int ch_i = ch;
cout << ch << " = " << ch_i;
```

char也可以进行整形计算，如'ch += 1'存的整数为78，表示的字符为下一个字符'N'。

对于转义字符，'\n'视作一个字符，表示换行。

关于'\n'和endl的选择问题:

1. 对于较长的字符串可以使用'/n'
2. 对于变量的输出结束可以用endl

```c++
int n = 10;
cout << 'The number is \n';
cout << n << endl';
```

对于128无法表示的字符，还存在宽字符: wchar_t，char16_t，char32_t

### 3.1.8 bool类型

bool值只有两种状态: 非零值-真，零值-假

二者都是可以赋值给整形，而对于数值和指针也可以**隐式转换**为bool

## 3.2 const限定符

const: 常量被初始化后，其值就被固定了，编译器将不允许再修改该常量的值(修改报错)。

对于常量，常会把**变量首字符大写**，有助于区分变量类型，#define则是全大写。

> 在c++中，无论是定义类型，还是在定义域中，const都要优于#define

## 3.3 浮点数

浮点数的由来: 表示小数点的位置在数字相同大小不同的数中主要是位置变化

### 3.3.1 书写浮点数

书写方式:

1. 标准小数点(对于数字相对较少的数)，9.0，0.001
2. E表示法(大小均可，正负表示小数点前后位置)，8.33E-4

### 3.3.2 浮点类型

float至少32位，doubel至少48位，long doubel至少和dobel一致

关于精度:

1. float至少6位有效位上是精确的，超出就不精确
2. doubel在更多的有效位上都精确，对于浮点变量优先doubel

### 3.3.3 浮点数优缺点

优点:

1. 可以表现整数中值
2. 存在缩放因子，表示的数可以大很多

缺点:

1. 运算速度比整数慢
2. 运算中精度会降低(和float精确位数有限同源，对于超过精确位的运算就会有误)

### 3.3.4 运算精度的问题(补充)

c++中float和doubel的结构:

![precision](https://www.rumenz.com/static/cimg/20180828/1535446117.png)

浮点数存储中用的都是科学计数法，如对于8.25，存的就是 $8.25 \times e^{-2}$，而在计算机中，浮点数要用二进制的科学计数法表示。

> 浮点数的二进制，整数部分(除2) + 小数部分(乘2)

此时8.25，二进制浮点数就是1000.01，而二进制科学计数法则是 $1.00001 \times 2^3$，符号为正，指数为3，小数位00001。

因此对于float，就有了表示符号的符号位(1bit)，指数(8位)，小数(23位)。其中指数部分需要区分表示正指数(小数点左移)，负指数(小数点右移动)。

区分正负指数需要加上一个中间数127，如 $2^{-10}$，在指数部分的2进制数就是-10+127=117，即 0111 0101。

最后将三者合并就有了浮点数在内存中的表示。

几个关于浮点数的问题:

1. 关于为什么float在10位小数中精度只有6位，**四位二进制数可以表示一个10进制数，由于小数默认有小数点前一位**，加上表示小数的23位，共24位，即得6位的10进制数。
2. double转换到10进制有13位，超出以后计算依然不准确

计算机中，对于不能对2取整的小数，在二进制上永远是近似值，而float和double的位数限制，所以不能精确。

## 3.4 c++算数运算符

对于程序中出现结果误差，参见上面的解释(float位数有限)，尽量不使用float，使用double保证小数点后位数足够。

### 3.4.1 运算优先级结合性

优先级:

1. 乘除高于加减
2. 乘除顺序从左到右结合

### 3.4.2 除法分支

> 除法运算符（/）的行为取决于操作数的类型。

对于整数，会去掉小数；对于浮点数，则会保留。对于类型不同的除法运算，会提升到同一数据类型计算，即**运算符重载**

### 3.4.3 求模运算符

常用于计算余数

### 3.4.4 类型转换

发生类型转换的情况:

1. 赋值运算出现
2. 表达式包含不同类型
3. 参数传递给函数

#### 1） 赋值运算

对于赋值运算的转换，会改变内存大小，由小到大不会出现问题，而由大到小，则会出现精度降低(类型转换不可靠)

几种典型问题:

1. double->float: 精度降低，也可能溢出(超出取值范围)
2. 浮点->整型: 小数丢失，也可能溢出
3. long->short: 溢出，通常只复制右边字节

#### 2) {}初始化进行转换

{}初始化: 列表初始化

这种转换有严格限制，不允许缩窄(narrowing)，即类似浮点->整型，也不能用变量(因为变量内容会变，出现潜在的风险)

#### 3) 表达式中的转换

存在两种自动转换: 变量出现时的自动转换，与其他类型同时出现的自动转换

1. 在计算表达式时，C++将bool、char、unsigned、char、signed char和short值转换为int。
2. 当运算涉及两种类型时，较小的类型将被转换为较大的类型。

> 这其中设计的思想其实就是**数据类型提升**，目的是为了提升整体运算精度

几大转换规则都遵守**就高不就低**

#### 4) 传递参数转换

传递参数时的类型转换通常由C++函数原型控制。(也可以取消，但不推荐)

#### 5) 强制类型转换

强制转换的通用格式:

```c++
(typeName) value // more in c
typeName (value) // new in c++
```

static_cast<>，也是强制转换，更严格:

```c++
static_cast<long> (thorn)
static_cast<typeName> (value)
```

### 3.4.5 auto声明

在初始化声明中，如果使用关键字auto，而不指定变量的类型，编译器将把变量的类型设置成与初始值相同(自动决定)。

```c++
auto n = 100; // int
auto x = 1.5; // dounbel
auto y = 1.3E12L; // long doubel
```

但auto对于一些期望指定的变量类型还是有差异的，谨慎使用。
